/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*

Еще один инструмент управления синхронизацией потоков представляет класс Mutex или мьютекс, который также 
располагается в пространстве имен System.Threading.

Так, возьмем пример с оператором lock из одной из предыдущих тем, в котором применялась синхронизация потоков:

*/


static void BeforeEx()
{
    int x = 0;
    object locker = new();  // объект-заглушка
    // запускаем пять потоков
    for (int i = 1; i < 6; i++)
    {
        Thread myThread = new(Print);
        myThread.Name = $"Поток {i}";
        myThread.Start();
    }
    
    
    void Print()
    {
        lock (locker)
        {
            x = 1;
            for (int i = 1; i < 6; i++)
            {
                Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
                x++;
                Thread.Sleep(100);
            }
        }
    }
}

BeforeEx();

/*

И перепишем данный пример, используя мьютексы:

*/

static void AfterEx()
{
    int x = 0;
    Mutex mutexObj = new();
    
    // запускаем пять потоков
    for (int i = 1; i < 6; i++)
    {
        Thread myThread = new(Print);
        myThread.Name = $"Поток {i}";
        myThread.Start(); 
    }
    
    void Print()
    {
        mutexObj.WaitOne();     // приостанавливаем поток до получения мьютекса
        x = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
        mutexObj.ReleaseMutex();    // освобождаем мьютекс
    }
}

AfterEx();

/*

Сначала создаем объект мьютекса:
	
Mutex mutexObj = new Mutex()

Основную работу по синхронизации выполняют методы WaitOne() и ReleaseMutex(). Метод mutexObj.WaitOne() 
приостанавливает выполнение потока до тех пор, пока не будет получен мьютекс mutexObj.

Изначально мьютекс свободен, поэтому его получает один из потоков.

После выполнения всех действий, когда мьютекс больше не нужен, поток освобождает его с помощью метода 
mutexObj.ReleaseMutex(). А мьютекс получает один из ожидающих потоков.

Таким образом, когда выполнение дойдет до вызова mutexObj.WaitOne(), поток будет ожидать, пока не 
освободится мьютекс. И после его получения продолжит выполнять свою работу.

*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

Console.ReadLine();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */