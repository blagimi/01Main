using Индексаторы;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Индексаторы.
Индексаторы позволяют индексировать объекты и обращаться к 
данным по индексу. Фактически с помощью индексаторов мы можем работать
 с объектами как с массивами. По форме они напоминают свойства со стандартными
  блоками get и set, которые возвращают и присваивают значение.
  Формальное определение индексатора
  модификатор_доступа возвращаемый_тип this [Тип параметр1, ...]
{
    get { ... }
    set { ... }
}
В отличие от свойств индексатор не имеет названия. Вмето него указывается ключевое
слово this, после которого в квадратных скобках идут параметры. Индексатор должен 
иметь как минимум один параметр.
*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Допустим есть класс Person который представляет человека и класс Company который
представляет некую компанию где работают люди. Используем индексаторы для определения
класса Company. Для хранения персонала компании в классе определен массив personal,
который состоит из объектов Person. Для доступа к этим объектам определен индексатор.
public Person this [int index]
Индексатор подобен описанием свойству. Для индексатора определяется тип в данном
случае Person. Тип индексатора определяет, какие объекты будет получать и возвращать
индексатор. Для индексатора определен параметр int index, через который обращаемся
к элементам внутри объекта Company.
Для возвращения объекта в индексаторе опеределен блок get => personal[index];
В блоке set как и в обычном свойстве получаем через параметр value переданный объект
Person и сохраняем его в массив по индексу.
set => personal[index] = value;
После этого можно работать с объектом Company как с набором объектов Person.
                                                              | Person, Company
*/

var microsoft = new Company(
[
    new Person ("Tom"), new Person("Bob"), new Person("Sam"), new Person("Alice")
]);
                    // Получение объекта из индексатора
Person firstPerson = microsoft[0];
Console.WriteLine(firstPerson.Name);
                    // Переустановка объекта
microsoft[0] = new Person("Mike");
Console.WriteLine(microsoft[0].Name);

/*
Если индексатору будут передан некорректный индекс, который отсутсвует в массиве Person
то будет получено исключение, как и в случае обращения напрямую к элементам массива.
Поэтому нужно предусмотреть дополнительную логику на этот случай. Например, проверку
переданного индекса. В примере если в блоке get переденный индекс имеется в массиве,
то возвращается объект по индексу. Если индекса в массиве - нет, то генерируется
исключение. Аналогично в блоке set устанавливается значение по индексу, если индекс
есть в массиве.
*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Индексы.
Индексатор получает набор индексов в виде параметров. Однао индексы необязательно должны
представлять тип int, устанавливаемые/возвращаемые значения необязательно хранить в
массиве. Можно рассматривать объект как хранилище атрибутов/свойств и передавать имя
атрибута в виде строки.
В данном случае индексатор в классе User в качестве индекса получает строку, которая
хранит название атрибута (в данном случае название поля класса)
В блоке get в зависимости от значения строкового индекса возвращается значение того 
или иного поля класса. Если передано неизвестное название, генерируется исключение.
В блоке set логика схожа по индексу определяем для какого поля надо установить значение.
                                                                    |   User
*/
User tom = new();
                                        // Установка значений
tom["name"]="Tom";
tom["email"]="Tom@gmail.ru";
tom["phone"]="+1234567";
                                        //Получаем сообщение
Console.WriteLine(tom["name"]);         //  Tom

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Применение нескольких параметров.
Так же индексатор может принимать несколько параметров. Допустим есть класс, в котором
хранилище определено в виде двухмерного массива или матрицы. Для определения индексатора
используется два индекса i,j. В программе мы должны обращаться к объекту используя два
индекса. Индексатор не может быть статическим и применяется только к экземпляру класса.
При этом индексаторы могут быть виртуальными и абстрактными и могут переопределяться в
производных классах.
                                                                        |   Matrix
*/

Matrix matrix = new();
Console.WriteLine(matrix[0,0]);
matrix[0,0] = 111;
Console.WriteLine(matrix[0,0]);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Блоки get и set.
Как и в свойствах, в индексаторах можно опускать блок get или set, если в них нет
необходимости. Например, удалим блок set и сделаем индексатор только для чтения.
Так же можно ограничивать доступ к блокам get и set, используя модификаторы доступа.
Можно их сделать приватными к примеру.
private set => numbers[i, j] = value;
*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Перегрузка индексаторов.
Подобно методам индексаторы можно перегружать. В этом случае также индексаторы должны
отличаться по количеству, типу или порядку используемых параметров. Класс company
содержит две версии индексатора. Первая версия получает и устанавливает объект Person
по индексу, а вторая - только получает объект Person по его имени.
                                                                    |   Company
*/

Console.WriteLine(microsoft["Bob"].Name);   //  Bob

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Определите класс футболиста, который содержит имя футболиста и его номер на поле. 
Определите класс футбольной команды, который хранит 11 футболистов в виде массива и
обеспечивает доступ к этим футболистам через индексатор.
*/

Team inter = new();
inter[0] = new Player { Name = "Ronaldo", Number = 9 };
inter[1] = new Player { Name = "R. Baggio", Number = 10 };
inter[2] = new Player { Name = "Simeone", Number = 8 };
 
Console.WriteLine(inter[1]?.Name);
/*
При попытке доступа к индексу, который выходит за границы массива получается исключение.
Исправьте код индексатора таким образом, что бы он позволял избежать использования
некорректных индексов. 
*/
//inter[20] = new Player { Name = "Ronaldo", Number = 9 };
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Даны классы Word и Dictionary. Класс word представляет слово, где свойство Target хранит
перевод слова. Класс Dictionary представляет словарь и хранит все слова в приватном
массиве. Добавьте в словарь индексатор таким образом что бы с помощью индексатора можно
было по слову получить или изменить его перевод. 
*/

Dictionary dict = new Dictionary();
Console.WriteLine(dict["Blue"]);
dict["Blue"] = "Голубой";
Console.WriteLine(dict["Blue"]);


Console.ReadLine();