/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*
 * Замыкания. (closure)
 * Представляет объект функции, который запоминает своё лексическое окружение даже в том 
 * случае когда она выполняется вне своей области видимости.
 * Замыкание включет три компонента.
 * - Внешняя функция, которая определяет некоторую область видимости и в которой 
 * определены некоторые переменные и параметры - лексическое окружение.
 * - Переменные и параметры(лексическое окружение), которые опеределены во внешней
 * функции. 
 * - Вложенная функция, которая использует переменные и параметры внешней функции. 
 * Реализуются замыкания различными способами, с помощью локальных функций и лямбда
 * выражений.
 */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*
 * Замыкание через локальные функции.
 * Здесь метод Outer в качестве возвращаемого типа имеет тип Action, т.е метод
 * возвратить функцию, которая не принимает параметров и имеет тип void.
 * Внутри переменная x - которая является лексическим окружением для внутренней
 * функции. Так же внутри метода Outer определена внутренняя функция - локальная
 * функция Inner, которая обращется к своему лексическому окружению - переменной х
 * и увеличивает её значение на 1, после чего выводит на консоль. Эта локальная функция
 * возвращается методом Outer. После вызова метода Outer получаем переменную fn локальную
 * функцию inner. Переменная fn представляет собой замыкание, т.е объеденяет две вещи:
 * функцию и окружение в котором функция была создана. Поэтому несмотря на то что, мы 
 * получили локальную функцию её можно вызвать вне метода в котором она определена,
 * она запомнила своё лексическое окружение и может к нему обращаться и изменять.
 */

var fn = Outer();               // fn = Inner, т.к метод Outer возвращает функцию Inner
fn();                           // 6 Вызов внутренней функции Inner   
fn();                           // 7
fn();                           // 8
Action Outer()                  // Метод или локальная функция
{
    byte x = 5;                 // Лексическое окружение - локальная переменная
    void Inner()                // Локальная функция
    {
        x++;                    // Операция с лексическим окружением
        Console.WriteLine(x);
    }
    return Inner;               // Возвращение локальной функции
}
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Реализация с помощью лямбда-выражений.
 * С их помощью можно сократить замыкания.
 */
var outerFn = () =>
{
    byte x = 10;
    var innerFn = () => Console.WriteLine(++x);
    return innerFn;
};
var fn2 = outerFn();            // fn2 = innerFn, т.к outerFn возвращает InnerFn
fn2();                          // 11 Вызов innerFn
fn2();                          // 12
fn2();                          // 13
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Приминение параметров.
 * Кроме внешних переменных к лексическому окружению так же относятся параметры 
 * окружающего метода. Внешняя функция Multiply возвращает функцию, которая принимает
 * число и возвращает число. Для этого определен делегат Operation, который представляет
 * возвращаемый тип. Вызов метода Multiply() возвращает локальную функцию которая соответствует
 * сигнатуре делегата Operation. Функция запоминает окружение в котором была создана,
 * в частности значение параметра Outher. Кроме того, сама принимает параметр inner и 
 * возвращает произвидение параметров outher и inner. 
 * Весь код можно было бы сократить при помощи лямбда-выражений.
 * var multiply = (int n) => (int m) => n*m;
 */
var fn3 = Multiply(5);          // 5 - outher
Console.WriteLine(fn3(5));      // 25
Console.WriteLine(fn3(6));      // 30
Console.WriteLine(fn3(7));      // 35
Operation Multiply(byte outherN)
{
    byte Inner(byte innerN)
    {
        Console.WriteLine($"{outherN}=(outher) {innerN}=(inner)");
        return Convert.ToByte(outherN * innerN);
    }
    return Inner;
}

delegate byte Operation(byte n);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */