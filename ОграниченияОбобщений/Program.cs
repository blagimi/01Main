using ОграниченияОбобщений;
/*
 * Ограничения обобщений.
 * С помощью универсальных(обобщенных) параметров можно типизировать классы любым типом.
 * Однако может возникнуть необходимость конкретизировать тип. Метод SendMessage в качестве
 * параметра message принимает объект класса Message и отправляет его. Но у Message могут
 * быть классы наследники, например EmailMessage, SmsMessage и так далее. Тогда будет 
 * выполняться преобразование от EmailMessage к Message, кроме того возможно возникнет
 * проблема тип безопастности. В таком случае можно применить обобщение. 
 */

/*
 * Ограничение методов.
 * После оператора where указывается универсальный параметр, для которого применяется
 * ограничение. Обычное ограничением выступает конкретный тип. 
 * void SendMessage<T>(T message) where T: Message
 * При вызове метода необязательно указывать тип в угловых скобках - компилятор на 
 * основании переданного значения сам определит каким типом является метод. Однако
 * можно это сделать и явно.
 */
Message.SendMessage(new Message("Hello Alex"));
Message.SendMessage<EmailMessage>(new EmailMessage("How are you?"));
/*
 * Ограничение обобщений в типах.
 * Подобным образом можно определять и ограничивать типы.
 * Внутри класса Messenger все объекты типа T можно использовать как объекты Message.
 */
Messenger<Message> telegram = new();
telegram.SendMessage(new Message("Hello world"));
Messenger<Message> outlook = new();
outlook.SendMessage(new EmailMessage("Bye world"));
/*
 * В качестве ограничений можно использовать следующие типы:
 * - Классы
 * - Интерфейсы
 * - class - универсальный параметр должен представлять класс
 * - struct - универсальный параметр должен представлять структуру
 * - new() - универсальный параметр должен представлять тип, который имеет public
 * конструктор без параметров
 * Имеются ввиду ограничение на типы значений:
 * class Messenger<T> where T: struct {}
 * Конкретные структуры указывать НЕЛЬЗЯ.
 * class Messenger<T> where T: class {}
 * class Messenger<T> where T: new() {}
 * устанавливает ограничение на класс ИЛИ структуру которые имеют public конструктор
 * без параметров. Если используются несколько ограничений, то они должны идти в порядке
 * 1) Название класса, class, struct. При этом можно определить только одно из этих 
 * ограничений.
 * 2) Название интерфейса
 * 3) new()
 * class Smartphone<T> where T: Messenger, new()
 */

/*
 * Использование нескольких универсальных параметров.
 * Если класс использует несколько универсальных параметров, то последовательно можно
 * задать оганичения к каждому из них. // Messenger2
 */
Messenger2<Message, Person> icq = new();
Person tom = new("Tom");
Person bob = new("Bob");
Message hello = new Message("Hello, Bob");
icq.SendMessage(tom, bob, hello);   // Отправитель: Tom Получатель: Bob Сообщение: Hello, Bob!