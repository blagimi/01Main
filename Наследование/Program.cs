/*
 * Наследование (inheritance) является одним из ключевых моментов ООП. 
 * Благодаря наследованию один класс может унаследовать функциональность другого класса.
 */

/*
 * Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:
 * 1) Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
 * 2) При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа 
 * к производному классу должен быть таким же, как и у базового класса, или более строгим. 
 * То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь 
 * тип доступа internal или private, но не public.
 * Однако следует также учитывать, что если базовый и производный класс 
 * находятся в разных сборках (проектах), то в этом случае производый класс может 
 * наследовать только от класса, который имеет модификатор public.
 * 3) Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и 
 * создавать производные классы. Например, следующий класс не допускает создание наследников:
 * sealed class Admin
 * {
 * }
 * 4) Нельзя унаследовать класс от статического класса.
 */
using Наследование;
Person person = new("Bob");
person.PrintName(); // Bob
Employee employee = new("Tom", "Microsoft");
employee.PrintName(); // Tom
/* 
 * аким образом, производный класс может иметь доступ только к тем членам базового класса, 
 * которые определены с модификаторами private protected (если базовый и производный класс 
 * находятся в одной сборке), public, internal (если базовый и производный класс находятся 
 * в одной сборке), protected и protected internal.
 */

/* base
 * С помощью ключевого слова base мы можем обратиться к базовому классу. 
 * В нашем случае в конструкторе класса Employee нам надо установить имя и компанию. 
 * Но имя мы передаем на установку в конструктор базового класса, то есть в конструктор класса 
 * Person, с помощью выражения base(name).
 */

/*
 * Конструкторы не передаются производному классу при наследовании. И если в базовом классе не 
 * определен конструктор по умолчанию без параметров, а только конструкторы с параметрами 
 * (как в случае с базовым классом Person), то в производном классе мы обязательно должны 
 * вызвать один из этих конструкторов через ключевое слово base.
 */