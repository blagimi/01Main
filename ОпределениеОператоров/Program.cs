using ОпределениеОператоров;
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*
* Наряду с методами в классах и структурах можно также определять операторы.
* Данный класс представляет счетчик, значение которого хранится в свойстве Value.
* Есть два объекта класса Counter - два счетчика, которые мы хотим сравнивать или 
* складывать на основании их свойства value, используя стандартные операции сравнения
* и сложения.
* На данный момент операции сравнения или сложения для объектов не доступны. Эти операции
* могут использоваться для примитивных типов. По умолчанию можно складывать числовые
* значения, но как складывать объекты комплексных типов - классов и структур компилятор
* не знает. Для этого нужно использовать перезагрузку операторов.
                                                            |   Counter
*/
Counter counter1 = new() { Value = 23 };
Counter counter2 = new() { Value = 45 };
bool result = counter1 > counter2;
Console.WriteLine(result);              //  false
/*
* Определение операторов заключается в оперделении в классе, для объектов которого
* мы хотим определить оператор, специального метода
* public static возвращаемый_тип operator оператор(Параметры) {}
Этот метод должен иметь модификаторы public static, так как перегружаемый оператор
будет использоваться для всех объектов данного класса. Далее название типа, это тот
тип который мы хотим получить. К примеру при сложении 2х объектов counter мы хотим
получить объект типа bool, который указывает истино или ложно условное выражение.
Но типы могут быть любыми, в зависимости от задачи. Затем вместо называния метода
идет ключевое слово operator и собственно сам оператор. Далее в скобках параметры.
Бинарные операторы принимают 2 параметра, унарные один. В любом случае один из 
параметров должен представлять тот тип класс или структуру, в котором определяется
оператор.
В примере все операторы - бинарные поэтому в каждой перегрузке по 2 параметра.
В результате мы получаем новый объект Counter в качестве возвращаемого типа.
*/
Counter counter3 = counter1 + counter2;
Console.WriteLine(counter3.Value);      //  23 + 45 = 68

/*
Так как перегруженный для определения оператор представляет собой метод, то этот
метод можно так же перегрузить, т.е создать еще одну версию. Данный метод складывает
значение свойства Value и некоторое число, возвращая их сумму.
*/
Counter counter4 = new() { Value = 23 };
int result2 = counter4 + 27;
Console.WriteLine(result2);                    //  50
/*
Не все операторы можно определить. 
унарные операторы +x, -x, !x, ~x, ++, --, true, false
бинарные операторы +, -, *, /, %
операции сравнения ==, !=, <, >, <=, >=
поразрядные операторы &, |, ^, <<, >>
логические операторы &&, ||
Кроме того, есть несколько операторов, которые надо определять парами:
== и !=
< и >
<= и >=
И есть ряд операторов, которые нельзя перегрузить, например, операцию равенства = 
или тернарный оператор ?:, а также ряд других. Полный список перегружаемых операторов 
можно найти в документации msdn
*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* 
Определение инкремента и декремента.
Следует учитывать что в коде оператора не должны изменяться те объекты, которые 
передаются в оператор через параметры. Например инкремента. Возвращаться должен 
новый объект, который содержит в свойстве Value инкрементированное значение. Оператор
НЕ ДОЛЖЕН менять значения своих параметров. При этом не нужно определеять отдельно
операторы для префиксного и постфиксного инкремента(а так же декремента), одна 
реализация будет работать в обоих случаях. При операциях постфиксног инкремента
компилятор сначала создает временную переменную, в которую сохраняет текущий объект.
Затем текущий объект замещает значением полученным из функции оператора. 
В качестве операции возвращается значение временной переменной. При префиксном 
инкременте компилятор возвращает новое значение, полученное из фукнции оператора.
                                                            | Counter2
*/
Counter2 counter21 = new() { Value = 10 };
Counter2 counter22 = counter21++;
Console.WriteLine(counter21.Value);     //  20
Console.WriteLine(counter22.Value);     //  10

Counter2 counter23 = ++counter21;
Console.WriteLine(counter21.Value);     //  30               
Console.WriteLine(counter23.Value);     //  30

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Определение операций true и false.
Эти операторы определяются, когда нужно использовать объект в качестве условия.
                                                            | Counter2
*/
Counter2 counter24 = new(){Value = 0};
if (counter24)
Console.WriteLine(true);
else
Console.WriteLine(false);
/*
Если необходимо использовать операцию отрицания типа if(!counter) её так же необходимо
определить. Операция отрицания фактически синонимична операции false, поэтому содержит
аналогичное условие.
*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Есть класс State, который представляет государство:
Добавьте в класс оператор сложения, который бы позволял объединять государства. А также
 операторы сравнения < и > для сравнения государств по какому-нибудь критерию 
 (например, по населению или территории).
                                                            | State
 */

 State state1 = new(1000,100);
 State state2 = new(2000,200);
 State state4 = new(){Population = 100, Area = 100};
 State state5 = new(){Population = 200, Area = 200};
 State state6 = state4+state5;
 State state3 = state1+state2;
 Console.WriteLine(state3.Area);
 Console.WriteLine(state3.Population);
 Console.WriteLine(state6.Area);
 Console.WriteLine(state6.Population);

bool isGreater = state1 > state2;
if (isGreater)
Console.WriteLine("State 1 больше");
else
Console.WriteLine("State 2 меньше");
/*
Как известно, неотъемлемыми компонентами бутерброда являются хлеб и масло. Допустим,
 у нас есть следующие классы: Добавьте в один из классов оператор сложения, чтобы при 
 объединении хлеба и масла получался бутерброд, и, тем самым, компилировался и выполнялся 
 без ошибок следующий код:
                                                            | Bread, Butter, Sandwich
 */

Bread bread = new() { Weight = 80 };
Butter butter = new() { Weight = 20 };
Sandwich sandwich = bread + butter;
Console.WriteLine(sandwich.Weight);         //  100

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
Console.ReadLine();
