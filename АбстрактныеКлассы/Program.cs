using АбстрактныеКлассы;
/*
 * Абстрактные классы и члены классов.
 * Некоторые сущности, которые мы хотим выразить с помощью языка программирования, 
 * могут не иметь конкретного воплощения. Например, в реальности не существует 
 * геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто 
 * фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами.
 * И для описания подобных сущностей, которые не имеют конкретного воплощения, 
 * предназначены абстрактные классы.
 */

/* 
 * Абстрактный класс похож на обычный класс. Он также может иметь переменные, методы, 
 * конструкторы, свойства. Единственное, что при определении абстрактных классов 
 * используется ключевое слово abstract.
 */

/*
 * Но главное отличие абстрактных классов от обычных состоит в том, 
 * что мы НЕ можем использовать конструктор абстрактного класса для создания 
 * экземпляра класса. Например, следующим образом:
 */
// Transport tesla = new Transport(); Ошибка

/* 
 * Тем не менее абстрактные классы полезны для описания некоторого общего функционала, 
 * который могут наследовать и использовать производные классы:
 */
Transport car = new Car();
Transport ship = new Ship();
Transport aircraft = new Aircraft();
/* 
 * В данном случае от класса Transport наследуются три класса, которые представляют 
 * различные типы транспортных средств. Тем не менее они имеют общую черту - они 
 * могут перемещаться с помощью метода Move()
 */
car.Move();
ship.Move();
aircraft.Move();

/*
 * Абстрактные члены классов
 * Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, 
 * которые определяются с помощью ключевого слова abstract и не имеют никакого функционала. 
 * В частности, абстрактными могут быть:
 * Методы
 * Свойства
 * Индексаторы
 * События
 * Абстрактные члены классов не должны иметь модификатор private. 
 * При этом производный класс обязан переопределить и реализовать все абстрактные методы 
 * и свойства, которые имеются в базовом абстрактном классе. При переопределении в 
 * производном классе такой метод или свойство также объявляются с модификатором override
 * (как и при обычном переопределении виртуальных методов и свойств). Также следует учесть, 
 * что если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, 
 * индексатор, событие), то этот класс должен быть определен как абстрактный.
 * Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса.
 * Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует
 * реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный 
 * этими абстрактными методами.
 */

/*
 * Абстрактные методы.
 * Например, выше в примере с транспортными средствами метод Move описывает передвижение 
 * транспортного средства. Однако различные типы транспорта перемещаются по разному - ездят
 * по земле, летят по воздуху, плывут на воде и т.д. В этом случае мы можем сделать метод
 * Move абстрактным, а его реализацию переложить на производные классы:
 */

/*
 * abstract class Transport
{
    public abstract void Move();
}
// класс корабля
class Ship : Transport 
{
    // мы должны реализовать все абстрактные методы и свойства базового класса
    public override void Move()
    {
        Console.WriteLine("Корабль плывет");
    }
}
car.Move();         // машина едет
*/

/*
 * Абстрактные свойства.
 * Следует отметить использование абстрактных свойств. Их определение похоже на определение 
 * автосвойств. 
 * abstract class Transport
{
    // абстрактное свойство для хранения скорости
    public abstract int Speed { get; set; } 
}
// класс корабля
class Ship: Transport
{
    int speed;
    public override int Speed 
    { 
        get => speed; 
        set => speed = value; 
    }
}
 
class Aircraft : Transport
{
    public override int Speed { get; set; }
}
 * В классе Transport определено абстрактное свойство Speed, которое должно хранить скорость
 * транспортного средства. Оно похоже на автосвойство, но это не автосвойство. Так как
 * данное свойство не должно иметь реализацию, то оно имеет только пустые блоки get и set. 
 * В производных классах мы можем переопределить это свойство, сделав его полноценным 
 * свойством (как в классе Ship), либо же сделав его автоматическим (как в классе Aircraft).
 */

/*
 * Отказ от реализации абстрактных членов
 * Производный класс обязан реализовать все абстрактные члены базового класса. Однако мы можем 
 * отказаться от реализации, но в этом случае производный класс также должен быть определен как абстрактный:
 * Transport tesla = new Auto();
 *  tesla.Move();           // легковая машина едет
 *  
abstract class Transport
{
    public abstract void Move();
}
// класс машины
abstract class Car : Transport{}
 
class Auto: Car
{
    public override void Move()
    {
        Console.WriteLine("легковая машина едет");
    }
}
 * В данном случае класс Car не реализует абстрактный метод Move базового класса Transport и поэтому также 
 * определен как абстрактный. Однако любые неабстрактные классы, производные от Car, все равно должны 
 * реализовать все унаследованные абстрактные методы и свойства.
 */

/*
 * Пример абстрактного класса
 * Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической 
 * фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и
 * прямоугольник имеют что-то общее и являются фигурами:
 */