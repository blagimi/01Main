using НеизменяемыйТипImmutableRecords;
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Records.
Records представляют новый ссылочный тип, который появился в C#9. Ключевая особенность 
records состоит в том, что они могут представлять неизменяемый (immutable) тип, который 
по умолчанию обладает рядом дополнительных возможностей по сравнению с классами и 
структурами. Зачем нам нужны неизменяемые типы? Такие типы более безопасны в тех
 ситуациях, когда нам надо гарантировать, что данные объекта не будут изменяться. 
В .NET в принципе уже есть неизменяемые типы, например, String.
Стоит отметить, что начиная с версии C# 10 добавлена поддержка структур record, 
соответственно мы можем создавать record-классы и record-структуры.
Для определения records используется ключевое слово record. Если определяется класс
 record, то ключевое слово class можно неиспользовать при определении типа:
 public record Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}

или так

public record class Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}

При определении структуры record при объявлении типа надо использовать ключевое слово struct:

public record struct Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
*/

/*
Хотя типы record предназначены для создания неизменяемых типов, однако одно только
применение ключевого слова record не гарантирует неизменяемость объектов record. 
Они являются неизменяемыми (immutable) только при определенных условиях. Например,
мы можем написать так:

var person = new Person("Tom");
person.Name = "Bob";
Console.WriteLine(person.Name); // Bob - данные изменились
 
public record Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
При выполнении этого кода не возникнет никакой ошибки, мы спокойно сможем изменять
 значения свойств объекта Person. Чтобы сделать его действительно неизменяемым,
  для свойств вместо обычных сеттеров надо использовать модификатор init.

var person = new Person("Tom");
person.Name = "Bob";    // ! ошибка - свойство изменить нельзя
 
public record Person
{
    public string Name { get; init; }
    public Person(string name) => Name = name;
}

В данном случае мы получим ошибку при попытке изменить значение свойств 
объекта Person.
Во многим records похожи на обычные классы и структуры, например, они могут 
абстрактными, их также можно наследовать либо запрещать наследование с помощью 
оператора sealed. Тем не менее есть и ряд отличий. Рассмотрим некоторые основные 
отличия records от стандартных классов и структур.
*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Сравнение на равенство
*/
var person1 = new Person("Tom");
var person2 = new Person("Tom");
Console.WriteLine(person1.Equals(person2)); // true
 
var user1 = new User("Tom");
var user2 = new User("Tom");
Console.WriteLine(user1.Equals(user2));     // false
 
 Console.ReadLine();
public record Person
{
    public string Name { get; init; }
 
    public Person(string name) => Name = name;
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
Оператор with
*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
Позиционные records
*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */



/*
Позиционные структуры для чтения
*/




/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
ToString
*/



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
Наследование
*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


