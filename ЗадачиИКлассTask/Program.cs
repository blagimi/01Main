/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Параллельное программирование и библиотека TPL
*/

#region Задачи и класс Task

/*

В эпоху многоядерных машин, которые позволяют параллельно выполнять сразу несколько процессов, стандартных средств
работы с потоками в .NET уже оказалось недостаточно. Поэтому во фреймворк .NET была добавлена библиотека 
параллельных задач TPL (Task Parallel Library), основной функционал которой располагается в пространстве 
имен System.Threading.Tasks. Данная библиотека упрощает работу с многопроцессорными, многоядерными 
системами. Кроме того, она упрощает работу по созданию новых потоков. Поэтому обычно рекомендуется 
использовать именно TPL и ее классы для создания многопоточных приложений, хотя стандартные средства и класс 
Thread по-прежнему находят широкое применение.

В основе библиотеки TPL лежит концепция задач, каждая из которых описывает отдельную продолжительную операцию. 
В библиотеке классов .NET задача представлена специальным классом - классом Task, который находится в 
пространстве имен System.Threading.Tasks. Данный класс описывает отдельную задачу, которая запускается 
асинхронно в одном из потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке. 
Однако в любом случае следует отметить, что задача - это не поток.

Для определения и запуска задачи можно использовать различные способы.

    Первый способ создание объекта Task и вызов у него метода Start:
    
    Task task = new Task(() => Console.WriteLine("Hello Task!"));
    task.Start();

    В качестве параметра объект Task принимает делегат Action, то есть мы можем передать любое действие, 
    которое соответствует данному делегату, например, лямбда-выражение, как в данном случае, или ссылку на 
    какой-либо метод. То есть в данном случае при выполнении задачи на консоль будет выводиться строка "Hello Task!".

    А метод Start() собственно запускает задачу.

    Второй способ заключается в использовании статического метода Task.Factory.StartNew(). Этот метод 
    также в качестве параметра принимает делегат Action, который указывает, какое действие будет выполняться. 
    При этом этот метод сразу же запускает задачу:
    	
    Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));

    В качестве результата метод возвращает запущенную задачу.

    Третий способ определения и запуска задач представляет использование статического метода Task.Run():
    	
    Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

    Метод Task.Run() также в качестве параметра может принимать делегат Action - выполняемое действие и 
    возвращает объект Task.

Определим небольшую программу, где используем все эти способы:

*/

Task task1 = new Task(() => Console.WriteLine("Task1 is executed"));
task1.Start();
 
Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task2 is executed"));
 
Task task3 = Task.Run(() => Console.WriteLine("Task3 is executed"));

/*

Итак, в данном коде задачи создаются и запускаются, но при выполнении приложения на консоли мы можем не 
увидеть ничего. Почему? Потому что когда поток задачи запускается из основного потока программы - потока 
метода Main, приложение может завершить выполнение до того, как все три или даже хотя бы одна из трех задач 
начнет выполнение. Чтобы этого не произошло, мы можем программным образом ожидать завершения задачи.

*/

#endregion


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

Console.ReadLine();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */