using КовариантностьИКонтравариантностьОбобщенныхИнтерфейсов;
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Ковариативность и контрвариатность обобщенных интерфейсов.
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Понятия ковариативности и контрвариативности связаны с возможностью использовать
 * в приложении вместо некоторого типа другой тип, который находится ниже или выше в
 * иерархии наследования.
 * Имеется три возможных варианта поведения:
 * - Ковариативность позволяет использовать более конкретный тип, чем заданный изначально
 * - Контрвариативность позволяет использовать более универсальный тип, чем заданный
 * изначально
 * Инвариативность позволяет использовать только заданный тип.
 * Можно создавать ковариативные и контрвариатные обобщенные интерфейсы. Эта
 * функциональность повышает гибкость при использовании обобщенных интерфейсов в 
 * программе. По умолчанию все обобщенные интерфейсы являются инвариантными.
 * Здесь определен класс сообщения Message, который получает через конструктор текст
 * и сохраняет его в свойство Text. А класс EmailMessage представляет условное email
 * сообщение и просто вызывает конструктор базового класса, передавая ему текст
 * сообщения.
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Ковариативные интерфейсы.
 * Обобщенные интерфейсы могут быть ковариантными, если к универсальному параметру
 * применяется ключевое слово out. Такой параметр должен представлять тип объекта,
 * который возвращается из метода.
 */

/*
 * Здесь обобщенный интерфейс IMessenger представляет интерфейс мессенджера и 
 * определяет метод WriteMessage() для создания сообщения. При этом на момент определения
 * интерфейса мы не знаем, объект какого типа будет возвращаеться в этом методе. 
 * Ключевое слово out в определении интерфейса указывает, что данный интерфейс будет
 * ковариативным. Класс EmailMessenger который представляет условную программу для
 * оправки email-сообщений, реализует это интерфейс и возвращает из метода WriteMessage()
 * объект EmailMessage.
 */

IMessenger<Message> outlook = new EmailMessenger();
Message message = outlook.WriteMessage("Hello world");
Console.WriteLine(message.Text);        //  Email: Hello World

IMessenger<EmailMessage> emailClient = new EmailMessenger();
IMessenger<Message> messenger = emailClient;
Message emailMessage = messenger.WriteMessage("Hi");
Console.WriteLine(emailMessage.Text);   //  Email: Hi

/*
 * Т.е можно присвоить более общему типу IMessenger<Message> объект более конкретного
 * типа EmailMessenger или IMessenger<EmailMessage>. Если бы не использовалось out
 * interface IMessenger<T>
 * тогда была бы ошибка 
 * IMessenger<Message> outlook = new EmailMessenger();  // ! Ошибка
 * IMessenger<EmailMessage> emailClient = new EmailMessenger();
 * IMessenger<Message> messenger = emailClient;  // ! Ошибка
 * Поскольку в этом случае невозможно было бы привести объект IMessenger<EmailMessage>
 * к типу IMessenger<Message>
 * При создании ковариантного интерфейса надо учитывать, что универсальный параметр может 
 * использоваться только в качестве типа значения, возвращаемого методами интерфейса. Но
 * не может использоваться в качестве типа аргументов метода или ограничения методов 
 * интерфейса.
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* 
 * Контравариантные интерфейсы
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */