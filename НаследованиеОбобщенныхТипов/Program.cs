using НаследованиеОбобщенныхТипов;
/*
 * Наследование обобщенных типов.
 * Один обобщенный класс может быть унаследован от другого обобщенного. При этом
 * можно использовать разные варианты наследования.
 */

/*
 * Первый вариант заключается в создании класса-наследника, который типизирован тем
 * же типом, что и базовый.                                 || Person, UniversalPerson
 */

Person<string> person1 = new("34");
Person<int> person3 = new UniversalPerson<int>(45);
UniversalPerson<int> person2 = new(33);
Console.WriteLine($"{person1.Id},{person2.Id},{person3.Id}");   // 34, 33, 45

/*
 * Второй вариант представляет создание обычного необобщенного класса-наследника. 
 * В этом случае при наследовании у базового класса надо явным образом определить тип.
 *                                                           || Person, StringPerson
 * Теперь в производном классе будет использоваться тип string.
 */
StringPerson person4 = new("123");
Person<string> person5 = new StringPerson("124");
//Person<int> person6 = new StringPerson("125"); Ошибка, может быть только string
Console.WriteLine($"{person4.Id},{person5.Id}");    // 123, 124

/*
 * Третий вариант это типизация наследника параметром другого типа, отличного от
 * универсального параметра в базовом классе. Для базового класса так же требуется
 * указать тип.                                               || Person, IntPerson
 * Класс наследник типизирован еще одним типом, который может не совпадать с типом
 * базового класса.
 */
IntPerson<string> person7 = new(5, "r456");
Person<int> person8 = new IntPerson<long>(7, 4567);
Console.WriteLine($"{person7.Id},{person8.Id}");    // 5, 7
/*
 * Так же можно сочетать использование универсального параметра из базового класса
 * с применением своих параметров.                              || Person, MixedPerson
 * Тут к унаследованному от базового класса параметру T
 * добавляется новый параметр K. Если необходимо задать ограничения, мы их можем указать
 * после названия базового класса. 
 */
MixedPerson<string, int> person9 = new("456", 356);
Person<string> person10 = new MixedPerson<string, int>("987", 35678);
Console.WriteLine($"{person9.Id},{person10.Id}");   // 456, 987
/*
 * При этом стоит учитывать, что если на уровне базового класса для универсального 
 * параметра установлено ограничение, то подобное ограничение должно быть определено 
 * и в производных классах, которые также используют этот параметр:
 * class Person<T> where T : class
 * {
 *     public T Id { get;}
 *     public Person(T id) => Id = id;
 * }
 * class UniversalPerson<T> : Person<T> where T: class
 * {
 *     public UniversalPerson(T id) : base(id) { }
 * }
 * То есть если в базовом классе в качестве ограничение указано class, то есть любой класс,
 * то в производном классе также надо указать в качестве ограничения class, 
 * либо же какой-то конкретный класс.
 */