/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/*
Класс Lock и синхронизация

Начиная с версии .NET 9 во фреймворк был добавлен новый API для синхронизации в виде 
класса System.Threading.Lock. Класс Lock служит для синхронизации доступа потоков к 
некоторой критической секции для предотвращения гонки за ресурсы между потоками. 
Есть разные варианты применения Lock. Рассмотрим их.
С оператором lock

Самый простой способ использования Lock- с оператором lock:
*/

int x = 0;  // некоторый общий ресурс
Lock _lockObj = new(); // объект-заглушка для синхронизации доступа
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}
 
void Print()
{
    lock(_lockObj)  // начало критической секции
    {
        x = 1;
        for (int i = 1; i < 5; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
    }  // завершение критической секции
}

/*

Данный пример похож на обычную синхронизацию с помощью оператора lock, когда в 
качестве заглушки используется произвольный объект. Здесь мы сначала определяем 
некоторый общий ресурс, к которому надо синхронизировать доступ - переменную x, 
и объект Lock синхронизации. Для примера здесь запускаем 5 потоков, каждый из 
которых обращается к некоторой общей секции в методе Print, где происходит доступ 
и изменение переменной x. Когда один поток захватывает объект _lockObj и входит 
критическую секцию, остальные потоки ждут освобождения _lockObj. После выхода из 
критической секции поток освобождает объект _lockObj для других потоков. В 
итоге мы получим синхронизированный доступ потоков следующего рода:

Поток 1: 1
Поток 1: 2
Поток 1: 3
Поток 1: 4
Поток 1: 5
Поток 2: 1
Поток 2: 2
Поток 2: 3
Поток 2: 4
Поток 2: 5
Поток 4: 1
Поток 4: 2
Поток 4: 3
Поток 4: 4
Поток 4: 5
Поток 5: 1
Поток 5: 2
Поток 5: 3
Поток 5: 4
Поток 5: 5
Поток 3: 1
Поток 3: 2
Поток 3: 3
Поток 3: 4
Поток 3: 5

ПО консольному выводу мы видим, что у нас получился синхронизированный доступ
 к переменной x.

*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

Console.ReadLine();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */