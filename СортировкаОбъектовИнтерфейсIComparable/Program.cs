using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using СортировкаОбъектовИнтерфейсIComparable;
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Сортировка объектов. Интерфейс IComparable.
 * Большинство встроенных в NET классов коллекций и массивы поддерживают сортировку.
 * С помощью одного метода, который, как правило, называется Sort() можно сразу
 * отсортировать по позрастанию весь надор данных. 
 */
int[] numbers = [97, 45, 32, 65, 83, 23, 15];
Array.Sort(numbers);
foreach (int n in numbers)
{
    Console.Write($"{n} ");
}
Console.WriteLine();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Однако метод Sort по умолчанию работает только для примитивных типов, как int
 * и string. Для сортировки наборов сложных объектов применяется интерфейс IComparable.
 * Он имеет всего один метод. Метод CompareTo предназначен для сравнения текущего
 * объекта с объектом, который передается в качестве параметра object? o . На выходе
 * он возвращет целое число, которое может иметь одно из 3х значений:
 * - Меньше нуля. Значит текущий объект должен находится перед объектом, который 
 * передается в качестве параметра.
 * - Равен нулю. Значит, оба объекта равны.
 * - Больше нуля. Значит, текущий объект должен находится после объекта, передаваемого
 * в качестве параметра.
 */

/*
 * Здесь в качестве критерия сравнения выбрано свойство Name объекта Person. Поэтому
 * при сравнении здесь фактиески идет сравнение значения свойства Name текущего
 * объекта и свойства Name, объекта, переденного через параметр. Если вдруг объект
 * не удастся привести к типу Person, то выбрасывается исключение.
 *                                                      | Person, IComparable
 */
var tom = new Person("Tom", 37);
var bob = new Person("Bob", 41);
var sam = new Person("Sam", 25);

Person[] people = [tom, bob, sam];
Array.Sort(people);
foreach (Person person in people)
{
    Console.WriteLine($"{person.Name} - { person.Age}");
}

Console.WriteLine();
/*
 * Аналогичным образом мы можем сравнивать по возрасту:
 *                                                       | Person2, IComparable
 */
var tom2 = new Person2("Tom", 37);
var bob2 = new Person2("Bob", 41);
var sam2 = new Person2("Sam", 25);

Person2[] people2 = [tom2, bob2, sam2];
Array.Sort(people2);
foreach (Person2 person2 in people2)
{
    Console.WriteLine($"{person2.Name} - {person2.Age}");
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Приминение компаратора.
 * Кроме интерфейса IComparable NET так же предоставляет интерфейс IComparer.
 * Метод Compare предназначен для сравнения двух объектов о1 и о2. Он так же возвращает
 * 3 значения, в зависимости от результата сравнения.
 * - Если первый объект больше второго то возвращается БОЛЬШЕ 0
 * - Если меньше то возвращается МЕНЬШЕ 0
 * - Если оба равны возвращается 0
 */

/*
 * Компаратор объектов Person. Пусть он сравнивает объекты в зависимости от длины строки
 * значения свойства Name. В данном случае используется обобщенная версия интерфейса
 * IComparer, что бы не делать излишних преобразований типов. Приминение:
 *                                                      | Person, PersonComparer, IComparer
 */

Console.WriteLine();

var alice = new Person3("Alice", 41);
var joy = new Person3("Joy", 37);
var kate = new Person3("Kate", 25);

Person3[] people3 = [alice, joy, kate];
//Array.Sort(people3, new PeopleComparer());

/*
 * КОД НЕ РАБОТАЕТ
 */

foreach (Person3 person3 in people3)
{
    Console.WriteLine($"{person3.Name}-{person3.Age}");
}