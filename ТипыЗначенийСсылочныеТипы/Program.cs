/*
 * Память делится на два типа: стек и куча (heap). Параметры и переменные метода, которые представляют типы значений, 
 * размещают свое значение в стеке. Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый
 * добавляемый элемент помещается поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. 
 * Физически стек - это некоторая область памяти в адресном пространстве.
 * Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается
 * указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место.
 * При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных. 
 */
/* Копирование значений
 * Тип данных надо учитывать при копировании значений. При присвоении данных объекту значимого 
 * типа он получает копию данных. При присвоении данных объекту ссылочного типа он получает не 
 * копию объекта, а ссылку на этот объект в куче
 */
using ТипыЗначенийСсылочныеТипы;

State state1 = new(); // Структура State
Console.WriteLine(state1.y);
State state2 = new()
{
    x = 1,
    y = 2
};
state1 = state2;
state2.x = 5; // state1.x=1 по-прежнему
Console.WriteLine(state1.x); // 1
Console.WriteLine(state2.x); // 5

Country country1 = new(); // Класс
Console.WriteLine(country1.x);
Country country2 = new()
{
    x = 1,
    y = 4
};
country1 = country2;
country2.x = 7; // теперь и country1.x = 7, так как обе ссылки и country1 и country2 
                // указывают на один объект в хипе
Console.WriteLine(country1.x); // 7
Console.WriteLine(country2.x); // 7
/* 
 * Так как state1 - структура, то при присвоении state1 = state2 она получает копию структуры state2. 
 * А объект класса country1 при присвоении country1 = country2; получает ссылку на тот же объект, на 
 * который указывает country2. Поэтому с изменением country2, так же будет меняться и country1.
*/

/*Ссылочные типы внутри типов значений
Теперь рассмотрим более изощренный пример, когда внутри структуры у нас может быть 
переменная ссылочного типа, например, какого-нибудь класса:
*/
State state3 = new();
Console.WriteLine(state3.y);
State state4 = new();

state4.country.x = 5;
state3 = state4;
state4.country.x = 8; // теперь и state1.country.x=8, так как state1.country и state2.country
                      // указывают на один объект в хипе
Console.WriteLine(state3.country.x); // 8
Console.WriteLine(state4.country.x); // 8
/* Переменные ссылочных типов в структурах также сохраняют в стеке ссылку на объект в хипе. И при присвоении двух структур state1 = state2; 
 * структура state1 также получит ссылку на объект country в хипе. Поэтому изменение state2.country повлечет за собой также изменение state1.country.
 */

/* 
 * Объекты классов как параметры методов.
 * При передаче объекта класса по значению в метод передается копия ссылки на объект. Эта копия указывает на тот же объект, что и исходная ссылка, 
 * потому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект. Поэтому в примере выше сработает только строка person.name = "Alice".
 * А другая строка person = new Person { name = "Bill", age = 45 } создаст новый объект в памяти, и person теперь будет указывать на новый объект в памяти. 
 * Даже если после этого мы его изменим, то это никак не повлияет на ссылку p в методе Main, поскольку ссылка p все еще указывает на старый объект в памяти.
 */
Person p = new() { name = "Tom", age = 23 };
ChangePerson(p);

Console.WriteLine(p.name); // Alice
Console.WriteLine(p.age); // 23

static void ChangePerson(Person person)
{
    // сработает
    person.name = "Alice";
    // сработает только в рамках данного метода
    person = new Person { name = "Bill", age = 45 };
    Console.WriteLine(person.name); // Bill
}
/* Но при передаче параметра по ссылке (с помощью ключевого слова ref) в метод в качестве аргумента передается сама ссылка на объект в памяти. 
 * Поэтому можно изменить как поля и свойства объекта, так и сам объект:
 * ChangePerson(ref p);
 */

struct State
{
    public int x;
    public int y;
    public Country country;
    public State()
    {
        x = 0;
        y = 0;
        country = new Country();
    }
}
