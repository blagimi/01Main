using System.Diagnostics;
using ПерегрузкаОперацийПреобразованияТипов;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Перегрузка операций преобразования типов.
Ранее были рассмотрены явные и неявные преобразования примитивных типов.
int x = 50;
byte y = (byte)x;                       // Явное преобразования от int к byte
int z = y;                              // Не явное преобразование от byte к int
С помощью перегрузки операторов можно определять логику преобразования одних типов
в другие. Для этого используется метод следующей формы
public static impicit|explicit operator тип_в_который_преобразовать(исходный_тип param)
{
    // какая-то логика
}
После помификаторов public static идет ключевое слово explicit(Если преобразование
явное, то есть нужно операция приведения типов) или implicit(Если преобразование
неявное). Затем идет ключевое слово operator и далее возвращаемый тип, в который надо
преобразовать объект. В скобках в качестве параметра объект который надо преобразовать.
*/

/*
Например, есть класс Counter представляющий счётчик-секундомер который хранит
количество секунд в свойстве Seconds.
Первый оператор преобразует число - объект типа int к типу Counter. Его логика проста
создается новый объект Counter у которого устанавливается свойство Seconds.
Второй оператор преобразует объект Counter к типу int, то есть получает из Counter
число.
                                                            |   Counter
*/
Counter counter1 = new() {Seconds = 23};
int x = (int)counter1;
Console.WriteLine(x);                   //  23
Counter counter2 = x;
Console.WriteLine(counter2.Seconds);    //  23
/*
Поскольку операция преобразования из Counter в int определена с ключевым словом
explicit т.е как явное преобразование, то в этом случае необходимо применить
операцию привидения типов. 
int x = (int)counter1;
В случае операцией преобразования типов должен преобразовать из типа или в тип, в 
который оператор опеределен. То есть оператор преобразования, определенный в типе 
Counter должен либо принимать в качестве параметра объект типа Counter либо возвращать
объект типа Counter.
*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Рассмотрим более сложное преобразование, от одного составног типа в другой составной тип.
Класс Timer представляет условный таймер, который хранит часы, минуты и секунды.
Класс Counter представляет условный счётчик-секундомер который хранит количество секунд.
Исходя из этого можно определить логику преобразования. Например 3675 секунд это
1 час 1 минута и 15 секунд.
                                                                | Counter, Timer
*/
Counter counter3 = new(){Seconds = 115};
ПерегрузкаОперацийПреобразованияТипов.Timer timer = counter3;
                                            //  0:1:55
Console.WriteLine($"{timer.Hours}:{timer.Minutes}:{timer.Seconds}");

Counter counter4 = (Counter)timer;
Console.WriteLine(counter4.Seconds);        //  115

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Дан класс Clock который хранит количество часов, в программе можно из числа получить
количество часов и наоборт из количества часов значение типа int. Добавить в класс
Clock оператор для неявного преобразования от типа int к типу Clock и оператор явного
преобразования от типа Clock к типу int.
                                                                |   Clock
*/
Clock clock = new();
int val = 34;
clock.Hours = val % 24;
val = clock.Hours;


Clock clock1 = new() {Hours =15};
int xClock1 = (int)clock1;
Console.WriteLine(xClock1);                 //  15

Clock clock2 = 13;
                                            //  13
Console.WriteLine($"Clock 2 hours: {clock2.Hours}");
clock2 = 34;  
                                            //  10                             
Console.WriteLine($"Clock 2 hours: {clock2.Hours}");

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Дано два класса Celcius и Fahrenheit. Класс цельсия представляет - градусник по цельсию.
А Фаренгейта - градусник по фаренгейту. Определить операторы преобразования от типа
Цельсия к Фаренгейту и наоборот.
Преобразование Фаренгейта (Tf) в температуру по шкале Цельсия (Tc): Tc = 5/9 * (Tf - 32).
Преобразование температуры Цельсия в температуру по шкале Фаренгейта: Tf = 9/5 * Tc + 32.
                                                                  |   Celcius,Fahrenheit
*/

Celcius celcius = new(){Gradus=30};
Fahrenheit fahrenheit = new(){Gradus=100};

Celcius celcius1 = (Celcius)fahrenheit;
//  100 по фаренгейту равно 37,77777777777778 по цельсию
Console.WriteLine($"{fahrenheit.Gradus} по фаренгейту равно {celcius1.Gradus} по цельсию");

Fahrenheit fahrenheit1 = (Fahrenheit)celcius;
//  30 по целью равно 86 по фаренгейту
Console.WriteLine($"{celcius.Gradus} по целью равно {fahrenheit1.Gradus} по фаренгейту");


Celcius celcius2 = new Celcius { Gradus = 25 };
Fahrenheit fahrenheit2 = celcius2;
Console.WriteLine(fahrenheit2.Gradus);      //  77
celcius2 = fahrenheit2;
Console.WriteLine(celcius2.Gradus);         //  25

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
Даны следующие класс Dollar Euro, оба представляют сумму.
Определить операторы преобразования от типа Dollar в Евро и наоборот. 
Допустим 1 евро стоит стоит 1,14 долларов. При этом один оператор должен подразумевать
явное и один неявное преобрзование.
                                                                    |   Dollar, Euro
*/

Dollar dollar = new(){Sum=100};
Euro euro = new(){Sum=100};

// Из 100 евро должно получиться 114 долларов

Dollar dollar1 = (Dollar)euro;
Console.WriteLine(dollar1.Sum);
// Из 100 долларов должно получиться 87.7 евро

Euro euro1 = dollar;
Console.WriteLine(euro1.Sum);

Console.ReadLine();