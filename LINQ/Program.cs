/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


#region Основы LINQ

/*

LINQ (Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

Существует несколько разновидностей LINQ:

LINQ to Objects: применяется для работы с массивами и коллекциями

LINQ to Entities: используется при обращении к базам данных через технологию Entity Framework

LINQ to XML: применяется при работе с файлами XML

LINQ to DataSet: применяется при работе с объектом DataSet

Parallel LINQ (PLINQ): используется для выполнения параллельных запросов

В этой главе речь пойдет прежде всего о LINQ to Objects, но в последующих материалах также будут затронуты и другие разновидности LINQ. Основная часть функциональности LINQ сосредоточена в пространстве имен System.LINQ. В проектах под .NET 6 данное пространство имен подключается по умолчанию.

В чем же удобство LINQ? Посмотрим на простейшем примере. Выберем из массива строки, которые начинаются на определенную букву, например, букву "T", и отсортируем полученный список:

*/

static void Example()
{
    string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };
    
    // создаем новый список для результатов
    var selectedPeople = new List<string>();
    // проходим по массиву
    foreach (string person in people)
    {
        // если строка начинается на букву T, добавляем в список
        if (person.ToUpper().StartsWith("T"))
            selectedPeople.Add(person);
    }
    // сортируем список
    selectedPeople.Sort();
    
    foreach (string person in selectedPeople)
        Console.WriteLine(person);
}

Example();

/*

Для отфильтрованных строк создается специальный список. Затем в цикле проходим по всем элементам массива и, если они соответствуют условию (начинаются на букву T), то добавляем их в этот список. Затем сортируем список по возрастанию. И в конце элементы полученного списка выводим на консоль:

Tim
Tom
Tomas
Хотя подобный подход вполне работает, однако LINQ позволяет значительно сократить код с помощью интуитивно понятного и краткого синтаксиса.

Для работы с колекциями можно использовать два способа:

Операторы запросов LINQ

Методы расширений LINQ

Рассмотрим оба способа

*/


#endregion


#region Операторы запросов LINQ

/*

Операторы запросов LINQ в каком-то роде частично напоминают синтаксис запросов SQL, поэтому если вы работали 
когда-нибудь с sql-запросами, то будет проще понять общую концепцию. Итак, изменим предыдущий пример, 
применив операторы запросов LINQ:
*/

static void Example2()
{
    string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };
    
    // создаем новый список для результатов
    var selectedPeople = from p in people // передаем каждый элемент из people в переменную p
                        where p.ToUpper().StartsWith("T") //фильтрация по критерию
                        orderby p  // упорядочиваем по возрастанию
                        select p; // выбираем объект в создаваемую коллекцию
    
    foreach (string person in selectedPeople)
        Console.WriteLine(person);
}

Example2();

/*    
Прежде всего, как мы видим, код стал меньше и проще, а результат будет тем же. В принципе все выражение 
можно было бы записать в одну строку:

var selectedPeople = from p in people where p.ToUpper().StartsWith("T") orderby p  select p;
Но для более понятной логической разбивки я поместил каждое отдельное подвыражение на отдельной строке.

Простейшее определение запроса LINQ выглядит следующим образом:

from переменная in набор_объектов
select переменная;
Итак, что делает этот запрос LINQ? Выражение from p in people проходит по всем элементам массива people и 
определяет каждый элемент как p. Используя переменную p мы можем проводить над ней разные операции.

Несмотря на то, что мы не указываем тип переменной p, выражения LINQ являются строго типизированными. 
То есть среда автоматически распознает, что набор people состоит из объектов string, поэтому переменная p 
будет рассматриваться в качестве строки.

Далее с помощью оператора where проводится фильтрация объектов, и если объект соответствует критерию 
(в данном случае начальная буква должна быть "T"), то этот объект передается дальше.

Оператор orderby упорядочивает по возрастанию, то есть сортирует выбранные объекты.

Оператор select передает выбранные значения в результирующую выборку, которая возвращается LINQ-выражением.

В данном случае результатом выражения LINQ является объект IEnumerable<T>. Нередко результирующая выборка 
определяется с помощью ключевого слова var, тогда компилятор на этапе компиляции сам выводит тип.

*/

#endregion

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

Console.ReadLine();

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */