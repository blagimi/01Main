using ИнтерфейсыВОбобщениях;
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Интерфейсы в обобщениях.
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Интерфейсы как ограничения обобщений.
 * Интерфейсы могут выступать в качестве ограничений обобщений. При этом если в качестве
 * ограничения можно указать только один класс, то интерфейсов можно указать несколько.
 * Интерфейс IMessage представляет интерфейс сообщения и определяет свойство Text для 
 * хранения текста сообщения. Интерфейс IPrintable определяет метод Print для условной
 * печати сообщения. И класс Message реализует эти интерфейсы.
 * В данном случае класс условного мессенджера использует параметр T - тип, который 
 * реализует сразу два интерфейса IMessage и IPrintable. Поэтому им можно типизировать
 * объекты Messenger.
 *                                              |Message,Messenger,IMessage,IPrintable
 */

// Создаем мессенджер
var telegram = new Messenger<Message>();
// Создаем сообщение
Message message = new("Hello World");
// Отправляем сообщение
telegram.Send(message);                 // Hello World

/*
 * Так же параметр Т может представлять интерфейс, который наследуется от обоих 
 * интерфейсов. В этом случае объекты Messenger можно типизировать типом IPrintableMessage
 *                                              |Messenger,IPrintableMessage,IPrintable,Imessage
 */

var telegram2 = new Messenger<IPrintableMessage>();
var message2 = new PrintableMessage("hello world");
telegram2.Send(message2);               //  hello world

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Обобщенные интерфейсы.
 * Как и классы интерфейсы могут быть обобщенными.
 * Интерфейс IUser типизирован параметром T, который при реализации интерфейса используется
 * в классе User. В частности, переменная id определена как T, что позволяет использовать
 * для id различные типы.
 * Возьмем 2 реализации в одной в качестве параметра будет использован тип int а в
 * другой тип string.
 *                                                |User,IUser
 */

IUser<int> user1 = new User<int>(6789);
Console.WriteLine(user1.Id);            //  6789
User<string> user2 = new User<string>("12345");
Console.WriteLine(user2.Id);            //  12345

/*
 * Так же при реализации интерфейса можно явно указать, какой тип будет использоваться
 * для параметра T:
 *                                                 |IntUser,IUser
 */

IUser<int> user3 = new IntUser(2345);
Console.WriteLine(user3.Id);            //  2345
IntUser user4 = new(9840);
Console.WriteLine(user4.Id);            //  9840

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */